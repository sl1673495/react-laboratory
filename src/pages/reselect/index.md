# Reselect 的基础使用

<code src="./index.tsx" />

## 要保持稳定的引用

如果不用 useCallback 包裹的话，每次渲染都会生成一次 selector，缓存值是保存在闭包
中的，肯定失效了。

## 默认浅比较

reselect 对于每一个选择器，默认是对参数的每一项参数进行 `===` 比较。

参数改变了，就会引发重新计算。

第一个按钮中，state 的引用变了，并且 bar 的值变了导致最后一个选择器接受到的参数
发生改变，所以重新计算了。

## 改变对象属性

其实这里在右边的按钮里，我是去更改了 state.bar 的值的，但是 selector 并不能感知到，最后一个选择器并没有重新计算。

这也说明了，它默认是对 `state` 这个参数进行 `===` 的比较的。

内层属性的变化，并不能触发 `selector` 的重新计算。

## 改变引用 但是不改变内部值

会引发前两个选择器重新计算 最后一个不会（因为 foo 和 bar 的实际值没变）

## 多层选择器嵌套组合的情况下

只要任意一层的选择器参数相同了，后续的执行都会中断，直接返回缓存后的值。
